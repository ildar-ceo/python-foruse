# -*- coding: utf-8 -*-## Watcher.# Мониторит файлы py на наличие изменений и перезапускает приложение когда они были измененыimport sysimport timeimport _threadloaded_modules_cache=set()is_watching = True# Возвращает список загруженных модулейdef get_loaded_modules_path():	paths=set()	for name in sys.modules:		try:			paths = paths + sys.modules[name].__file__		except:			pass	new = loaded_modules_cache - paths	return paths, newdef cache_loaded_modules(paths):	loaded_modules_cache = paths	def is_changed(paths):		return False		def restart_with_reloader():    while True:        args = [sys.executable] + ['-W%s' % o for o in sys.warnoptions] + sys.argv        if sys.platform == "win32":            args = ['"%s"' % arg for arg in args]        new_environ = os.environ.copy()        new_environ["RUN_MAIN"] = 'true'        exit_code = os.spawnve(os.P_WAIT, sys.executable, args, new_environ)        if exit_code != 3:            return exit_code		def watch():	global is_watching		paths, new = get_loaded_modules_path()	is_changed(paths)		while is_watching:		try:			time.sleep(1)						paths, new = get_loaded_modules_path()						if is_changed(paths):				is_watching = False								exit_code = restart_with_reloader()				sys.exit(exit_code)				except KeyboardInterrupt:			print('interrupted!')			sys.exit(-1)			pass		cache_loaded_modules(paths)	#!endwhile	#!enddef		def run_watch(main_func, *args, **kwargs):		_thread.start_new_thread(main_func, args, **kwargs)		watch()		pass#!enddef